---
name: principle-yagni
description: 识别并消除过度设计，确保只实现当前明确需要的功能。当需要评审功能范围、重构冗余代码、权衡技术债务时使用。覆盖功能必要性、过度设计信号、技术债务权衡三大维度，提供具体的识别标准和删减建议。
stage: COMMON
level_supported: [L1-STREAMLINED, L2-BALANCED, L3-RIGOROUS]
---

# YAGNI Principle Skill

> **Scope**: COMMON（全阶段通用）
>
> **版本**: 0.1.0（占位）| **创建日期**: 2025-11-27

---

## 概述

YAGNI（You Ain't Gonna Need It）是极限编程（XP）的核心原则：

```
┌─────────────────────────────────────────────────────┐
│              🎯 YAGNI Principle                     │
├─────────────────────────────────────────────────────┤
│  "Always implement things when you actually need   │
│   them, never when you just foresee that you       │
│   need them."                                      │
│                              — Ron Jeffries        │
└─────────────────────────────────────────────────────┘
```

---

## 检查维度

### 功能必要性

- [ ] 这个功能是当前需求明确要求的吗？
- [ ] 是否有用户/业务方确认需要？
- [ ] 删除这个功能会影响当前交付吗？

### 过度设计信号

- [ ] 是否为"将来可能需要"而设计？
- [ ] 是否有未使用的接口/参数/配置？
- [ ] 是否有"以防万一"的代码？
- [ ] 是否有过度抽象？

### 技术债务权衡

- [ ] 简单实现 vs 过度设计的成本
- [ ] 重构成本 vs 预测性设计成本
- [ ] 维护负担 vs 灵活性收益

---

## YAGNI 违反示例

❌ 不好的做法：
- 为"未来扩展"添加未使用的参数
- 创建只有一个实现的接口
- 预留"可能需要"的配置项
- 实现"完整"功能但只用 20%

✅ 好的做法：
- 实现当前需要的最简方案
- 需要时再重构扩展
- 保持代码精简可读

---

## 分级检查策略

### L1-STREAMLINED
- 检查 3 个核心问题
- 关注明显过度设计
- 通过标准：3 项中 2 项通过（≥67%）

### L2-BALANCED
- 检查 6-8 个关键点
- 扫描未使用的代码/接口
- 通过标准：6 项中 5 项通过（≥83%）

### L3-RIGOROUS
- 全面检查所有子项（10+ 项）
- 量化未使用代码比例（目标 < 3%）
- 记录技术债务和简化建议
- 通过标准：10 项中 9 项通过（≥90%）

---

## >> 命令

```
>>yagni_check_l1     # YAGNI 快速检查
>>yagni_unused       # 识别未使用的代码/功能
>>yagni_overdesign   # 过度设计检测
```

---

## 相关 Skills

- **同类**: principle-kiss, principle-dry, principle-soc（设计原则家族）
- **前置**: vertical-slice（只实现当前切片需要的）
- **应用**: task-breakdown（只分解当前需要的任务）
- **验证**: code-review（检查过度设计）

---

**TODO**: 待细化过度设计的检测规则
