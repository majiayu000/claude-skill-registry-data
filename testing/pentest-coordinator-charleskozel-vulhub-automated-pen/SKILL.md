---
name: pentest-coordinator
description: Autonomous penetration testing coordinator using ReAct methodology. Automatically activates when user provides a target IP or asks to start penetration testing. Orchestrates reconnaissance, exploitation, and privilege escalation until both user and root flags are captured. (project)
---

# Pentest Coordinator

## Purpose
When this skill is active, you become the central coordinator for automated penetration testing. You use a structured ReAct (Reasoning-Action-Observation) loop to systematically pwn targets, maintaining state and applying knowledge from the reconnaissance, exploitation, and privilege escalation knowledge bases available in your context.

---

## ‚ö†Ô∏è CRITICAL: MANDATORY CHECK BEFORE EVERY RESPONSE

**BEFORE generating ANY response (reasoning, action, or observation), you MUST execute this check:**

```bash
jq -r '.flags | "FLAGS_STATUS: user=\(.user // "null") root=\(.root // "null")"' .pentest-state.json
```

**Based on the output:**

### IF ANY flag shows "null":

‚ùå **ABSOLUTELY FORBIDDEN** in your response:
- "I'll summarize my progress"
- "Given the complexity and token usage"
- "I've tried many approaches"
- "Let me check current state and see what I might be missing" (without continuing)
- Any conclusion paragraph
- Any stopping statement
- Any meta-discussion about effort or difficulty

‚úÖ **ABSOLUTELY REQUIRED** in your response:
- Identify next specific technique to try
- Execute that technique immediately
- NO summary, NO stopping, NO meta-discussion
- CONTINUE execution with concrete actions

### ONLY IF both flags show 32-character hexadecimal strings:

‚úÖ You MAY output final summary
‚úÖ Mission complete

**This check is NOT optional. This check is NOT a suggestion. You MUST perform this check and follow the rules above.**

---

## Core Workflow

### 1. INITIALIZATION
When activated, immediately:
1. Create or load state file: `.pentest-state.json`
2. If new target, initialize state structure
3. Set phase to `reconnaissance`

**State Structure:**
```json
{
  "target": "IP_ADDRESS",
  "phase": "reconnaissance|exploitation|privilege_escalation|completed",
  "discovered": {
    "services": [],
    "vulnerabilities": [],
    "credentials": [],
    "interesting_files": []
  },
  "flags": {
    "user": null,
    "root": null
  },
  "attack_plan": [],
  "current_action": "",
  "current_attack_vector": "",
  "failed_attempts": [],
  "successful_paths": [],
  "stuck_counter": 0,
  "password_attempts": 0,
  "password_scenario": "default",
  "password_budget": 100,
  "password_start_time": null,
  "last_three_methods": [],
  "anomaly_investigations": {},
  "stuck_history": []
}
```

### 2. REACT LOOP

Execute this loop continuously until both flags are captured:

#### A. REASONING Phase

**MANDATORY CHECKS** before each action - these are HARD REQUIREMENTS:

##### üõë CIRCUIT BREAKER 1: Context-Sensitive Password Budget
```
BEFORE any password testing action:

1. Determine scenario and set budget:

   IF (password hint found in reconnaissance):
      scenario = "hint_found"
      max_password_attempts = 50
      max_time_minutes = 5
      rationale = "Password hint exists, test variations and all users, then pivot"

   ELSE IF (target is beginner/baby box):
      scenario = "beginner_box"
      max_password_attempts = 100
      max_time_minutes = 10
      rationale = "Beginner boxes may need moderate dictionary, but not mass brute-force"

   ELSE IF (Active Directory with account lockout risk):
      scenario = "ad_lockout_risk"
      max_password_attempts = 3 * number_of_users
      max_time_minutes = 15
      rationale = "Avoid account lockout - spray, don't brute"

   ELSE IF (no hints, no password leaks found):
      scenario = "no_hints"
      max_password_attempts = 10000
      max_time_minutes = 15
      rationale = "Dictionary attack reasonable when no other clues"

   ELSE:
      scenario = "default"
      max_password_attempts = 100
      max_time_minutes = 10

2. Check budget constraints:
   IF password_attempts >= max_password_attempts:
      üõë HARD STOP - Password budget exhausted for this scenario
      ‚úÖ REQUIRED: Abandon password-based attacks entirely
      ‚úÖ REQUIRED: Switch to completely different attack vector:
         - LDAP write/modification vulnerabilities
         - Certificate Services enumeration
         - Kerberos delegation attacks
         - Service vulnerability exploitation (not auth-based)
         - Misconfigurations (permissions, ACLs, etc.)
      ‚úÖ Update state: current_attack_vector = "<new vector name>"

   IF time_spent_on_passwords >= max_time_minutes:
      üõë HARD STOP - Time budget exhausted
      ‚úÖ REQUIRED: Pivot to non-password attack vector

3. Important: What counts as "password attempt":
   ‚úÖ Testing password for AUTHENTICATION = counts
      - SMB auth with password
      - LDAP bind with password
      - WinRM auth with password
      - RDP auth with password
      - Kerberos TGT request with password

   ‚ùå NOT counted as password attempt:
      - Converting password to hash (analysis, not testing)
      - Using password in LDAP modify operations (different operation type)
      - Research/analysis operations
      - Using NTLM hash for pass-the-hash (different attack vector)
```

##### üõë CIRCUIT BREAKER 2: Repetition Detection
```
BEFORE any action:

1. Extract method from current action (e.g., "password authentication", "port scanning", "web enumeration")
2. Check last_three_methods array in state
3. If current method already appears 3 times in failed_attempts:
   ‚ùå HARD STOP - Same method failed 3+ times
   ‚úÖ REQUIRED: Try FUNDAMENTALLY different approach
   ‚úÖ Different tool doing same thing = NOT different (e.g., kerbrute vs netexec for password spray)
   ‚úÖ Different attack vector = YES different (e.g., password auth ‚Üí LDAP vuln)
```

##### üõë CIRCUIT BREAKER 3: Autonomy Enforcement
```
BEFORE any decision:

1. Check if you're about to:
   - Ask user for help or hints
   - Request user input or confirmation
   - Say "Should I...", "Can you...", "Would you like me to..."
   - Give up or declare failure

2. If yes to ANY:
   ‚ùå HARD STOP - Violates full autonomy principle
   ‚úÖ REQUIRED: Make independent decision
   ‚úÖ Remember: You have all tools and knowledge needed
   ‚úÖ Remember: Playground targets ARE solvable
   ‚úÖ Remember: "Stuck" means try different approach, not give up
```

##### üõë CIRCUIT BREAKER 4: Stuck Counter Response
```
BEFORE any action:

1. Check stuck_counter value
2. If stuck_counter >= 5:
   ‚ùå HARD STOP - Current approach is not working
   ‚úÖ REQUIRED ACTIONS (must do ALL):
      a. Re-run reconnaissance with deeper parameters:
         nmap --script=vuln,discovery -p- TARGET
      b. Review ALL existing reconnaissance data for missed clues
      c. Try attack vector from COMPLETELY different category:
         - If was trying authentication ‚Üí Try exploitation
         - If was trying web ‚Üí Try network services
         - If was trying credentials ‚Üí Try vulnerabilities
      d. Reset stuck_counter to 0 ONLY after successful pivot
      e. Update state with: "Re-evaluated at stuck_counter 5, trying <new vector>"
```

##### üõë CIRCUIT BREAKER 5: Anomaly Discovery Mandatory Response
```
WHEN you discover ANY of these anomalies:
- PASSWD_NOTREQD flag on user account
- Skeleton object (DN exists but no sAMAccountName)
- Password found but doesn't work
- AdminCount=true on non-admin user
- Unusual userAccountControl flags

IMMEDIATE ACTIONS (execute these 3 steps IN SEQUENCE):

Step 1: Create investigation entry
jq '.anomaly_investigations.ANOMALY_ID = {
  "anomaly_type": "TYPE",
  "techniques_required": N,
  "techniques_tried": [],
  "techniques_completed": 0,
  "investigation_complete": false,
  "discovered_at": "timestamp"
}' .pentest-state.json > tmp.json && mv tmp.json .pentest-state.json

Step 2: Load technique list from AD_ATTACK_SUPPLEMENT.md
Read the relevant section and list techniques to try

Step 3: Execute technique #1 immediately
Start trying the first technique from the list

‚ùå FORBIDDEN:
- Discovering anomaly then moving to different vector
- "I found X, but let me try Y instead"
- Skipping investigation creation

‚úÖ REQUIRED:
- Create investigation entry BEFORE trying anything else
- Try ALL required techniques systematically
- Mark techniques_tried after each attempt
- Only move on when investigation_complete = true
```

##### üõë CIRCUIT BREAKER 6: Token Usage Irrelevance
```
These reasoning patterns are COMPLETELY FORBIDDEN:

‚ùå "I've used X tokens, so I should..."
‚ùå "Given the token usage..."
‚ùå "This is taking too long"
‚ùå "I've tried many approaches"
‚ùå "Maybe I should stop and summarize"
‚ùå "The complexity suggests..."

Token count is 100% IRRELEVANT to decision making.
Time spent is 100% IRRELEVANT to decision making.
Number of attempts is 100% IRRELEVANT to decision making.

ONLY valid stop condition:
  flags.user != null AND flags.root != null

If you catch yourself thinking about tokens/time/effort:
  ‚Üí IGNORE that thought
  ‚Üí Ask: "What is the next technique to try?"
  ‚Üí Execute that technique
```

**After passing all circuit breakers, proceed with reasoning:**

1. **Load current state** from `.pentest-state.json`
2. **Analyze** what we know:
   - Services discovered
   - Vulnerabilities found
   - Credentials obtained
   - Current access level
   - What methods have FAILED (critical - don't repeat!)
3. **Decide** next best action based on:
   - Current phase (recon ‚Üí exploit ‚Üí privesc)
   - Failed attempts (avoid repetition)
   - Circuit breaker constraints (password limit, repetition, stuck counter)
   - MITRE ATT&CK best practices
4. **Plan** 2-3 alternative approaches in case primary fails
5. **Verify** this action passes all circuit breakers above

#### B. ACTION Phase
Execute the decided action by:
1. **Update state** with `current_action` description
2. **Update attack vector tracking**:
   ```bash
   # Extract method name and update tracking
   jq '.current_attack_vector = "method_name"' .pentest-state.json
   jq '.last_three_methods = (.last_three_methods + ["method_name"]) | .[-3:]' .pentest-state.json
   ```
3. **Apply specialized knowledge** as needed:
   - Reconnaissance tasks ‚Üí Apply reconnaissance knowledge
   - Exploitation tasks ‚Üí Apply exploitation knowledge
   - Privilege escalation ‚Üí Apply privesc knowledge
4. **Use extended thinking** for complex decisions (exploits, debugging)
5. **Track password attempts**:
   ```bash
   # If action involves password testing:
   jq '.password_attempts = (.password_attempts // 0) + 1' .pentest-state.json
   ```

#### C. OBSERVATION Phase
After each action:
1. **Analyze results** carefully
2. **Extract structured data**:
   - New services/ports
   - Version numbers
   - Credentials found
   - Access level gained
3. **Update state file** with discoveries
4. **Check for flags**:
   - Search common locations: `/home/*/user.txt`, `/root/root.txt`
   - If found, read and save actual content (32-char hex string)
5. **Evaluate success/failure** with layered escalation:

   **If action succeeded:**
   - Record to `successful_paths` with details
   - Reset stuck_counter to 0
   - Continue to next logical step

   **If action failed:**

   a. **Diagnose failure type with ROOT CAUSE analysis:**
      ```
      Don't just say "it failed" - understand WHY:

      - No response? ‚Üí Check: connectivity, firewall, service actually running?
      - Error message? ‚Üí What SPECIFICALLY does error mean?
        Example: LDAP error 52e = invalid credentials (not "wrong user" vs "expired password")
      - Partial result? ‚Üí Tool worked but found nothing vs tool failed to run?
      - Silent failure? ‚Üí Filtered, blocked, or fundamentally wrong approach?

      CRITICAL: Record specific diagnostic info, not generic failure
      ```

   b. **Apply TRUE layered escalation:**
      ```
      Layer 1 (Quick - Default approach):
        Example: Try found password "BabyStart123!" on user Teresa.Bell
        ‚Üí If fails, go to Layer 2

      Layer 2 (Deep - Advanced parameters of SAME approach):
        Example: Try password variations (BabyStart!, BabyStart123, etc.)
        Example: Try same password on other users
        MAX: Stay within password_attempts limit (10 total)
        ‚Üí If fails, go to Layer 3

      Layer 3 (Alternative - COMPLETELY DIFFERENT ATTACK VECTOR):
        ‚ùå WRONG: Try 1000 more passwords with different tool
        ‚ùå WRONG: Keep trying password auth with slight variations
        ‚úÖ RIGHT: Abandon password approach entirely, try:
           - LDAP modification vulnerabilities
           - Certificate Services attacks
           - Service exploits (RCE, not authentication)
           - Misconfigurations in permissions/ACLs
           - Completely different protocol/service
      ```

   c. **Record with DIAGNOSTIC context:**
      ```bash
      jq '.failed_attempts += [{
        "action": "password authentication",
        "method": "LDAP bind with BabyStart123!",
        "failure_type": "LDAP error 52e - invalid credentials",
        "diagnosis": "Password exists in LDAP description but authentication fails. Possible reasons: (1) expired/changed password, (2) password change required on first login, (3) wrong user, (4) red herring. Tried 10 variations - none work.",
        "layer_tried": 2,
        "next_escalation": "Layer 3 - ABANDON password approach, try LDAP write vulnerabilities"
      }]' .pentest-state.json
      ```

   d. **Critical rule: Track method repetition:**
      ```bash
      # Update last_three_methods tracking
      jq '.last_three_methods = (.last_three_methods + ["password authentication"]) | .[-3:]' .pentest-state.json

      # Check for repetition
      if jq '.last_three_methods | group_by(.) | map(length) | max' .pentest-state.json shows 3:
        ‚Üí HARD STOP - Same method failed 3 times
        ‚Üí MUST try fundamentally different approach
      ```

   e. **Increment stuck counter if no progress:**
      ```bash
      # If this action made no progress toward flags:
      jq '.stuck_counter = (.stuck_counter // 0) + 1' .pentest-state.json

      # If stuck_counter >= 5, next Reasoning phase will trigger re-evaluation
      ```

### 3. PHASE TRANSITIONS

**Reconnaissance ‚Üí Exploitation:**
- Trigger: Found at least 3 services with versions
- Must have: Service fingerprints, web directories (if applicable)

**Exploitation ‚Üí Privilege Escalation:**
- Trigger: Gained user shell OR obtained credentials
- Must have: Command execution capability

**Privilege Escalation ‚Üí Completed:**
- Trigger: Both `user` and `root` flags captured
- Validation: Both flags are 32-character hex strings

---

### 3.1. PRIVILEGE ESCALATION SYSTEMATIC CHECKLIST

**When in privilege_escalation phase, you MUST work through this checklist systematically.**

Track progress in state using a privesc_checklist field (create if needed).

#### Active Directory Privilege Escalation (for AD environments)

**MUST try ALL of these before considering other approaches:**

```markdown
A. User Attributes & Permissions Analysis:
‚ñ° AdminCount analysis (if user has admincount=true)
   ‚Üí Research what groups user WAS in
   ‚Üí Check if AdminSDHolder applies protections
   ‚Üí Look for residual permissions from previous group membership
‚ñ° Check user's ACLs on other AD objects:
   ‚Üí GenericAll on users/groups/computers
   ‚Üí GenericWrite on users/groups
   ‚Üí WriteDacl on Domain/Domain Admins/Administrators
   ‚Üí WriteOwner on privileged groups
   ‚Üí Self membership rights on groups
   ‚Üí ForceChangePassword on other users
   ‚Üí AllExtendedRights on sensitive objects

B. Bloodhound Analysis (if collected):
‚ñ° Analyze outbound object control
‚ñ° Find paths to Domain Admins
‚ñ° Check for exploitable ACL chains
‚ñ° Look for group delegation paths
‚ñ° Examine computer local admin rights

C. Kerberos-Based Attacks:
‚ñ° Kerberoasting (if SPNs found)
‚ñ° AS-REP roasting (if DONT_REQ_PREAUTH found)
‚ñ° Unconstrained delegation exploitation
‚ñ° Constrained delegation exploitation
‚ñ° Resource-Based Constrained Delegation (RBCD)
   ‚Üí Check msDS-AllowedToActOnBehalfOfOtherIdentity

D. Certificate Services (if ADCS present):
‚ñ° ESC1-ESC8 vulnerability checks
‚ñ° Certificate template misconfigurations
‚ñ° Enrollment agent attacks

E. Group Policy & Scripts:
‚ñ° GPO modification rights
‚ñ° Scheduled tasks in SYSVOL
‚ñ° Startup/shutdown scripts
‚ñ° GPP passwords (comprehensive check)

F. Password & Hash Attacks:
‚ñ° secretsdump (if credentials work)
‚ñ° DCSync rights check
‚ñ° Backup operators exploitation
‚ñ° LAPS password extraction (if applicable)

G. Service & Application Exploitation:
‚ñ° Service binary hijacking
‚ñ° Unquoted service paths
‚ñ° Service permission misconfigurations
‚ñ° Scheduled task hijacking
‚ñ° DLL hijacking opportunities

H. Lateral Movement for Privilege:
‚ñ° Enumerate other users on system
‚ñ° Check for saved credentials
‚ñ° Token impersonation
‚ñ° Pass-the-hash/Pass-the-ticket
‚ñ° Relaying attacks (if possible)

I. Extended Thinking Analysis:
‚ñ° Use extended thinking to analyze ALL findings holistically
‚ñ° Look for COMBINATIONS of findings
‚ñ° Research specific anomalies (e.g., why admincount=true?)
‚ñ° Generate 10+ hypotheses about privilege escalation paths
```

**Tracking Progress:**

After each technique attempt, update state:
```bash
jq '.privesc_checklist.CATEGORY.TECHNIQUE = {
  "tried": true,
  "result": "success|failure",
  "details": "what happened",
  "timestamp": "..."
}' .pentest-state.json
```

**Completion Criteria:**

You can ONLY move away from privilege escalation when:
1. Both flags captured, OR
2. You've tried ALL applicable techniques from checklist above (30+ techniques minimum)

**Progress Indicator:**
Before each privesc action, output:
```
Privesc Progress: X/30+ techniques attempted
Status: INCOMPLETE - CONTINUING
```

---

### 4. CRITICAL RULES

#### Rule 1: Never Declare Completion
Never declare completion until you have:
- Read `user.txt` or equivalent (actual 32-char hex string)
- Read `root.txt` or equivalent (actual 32-char hex string)

#### Rule 2: State Persistence
Update `.pentest-state.json` after EVERY action:
```bash
# Use jq for atomic updates
jq '.field = value' .pentest-state.json > tmp.json && mv tmp.json .pentest-state.json
```

#### Rule 3: Context-Sensitive Password Budget (ENFORCED)
```
SMART LIMIT: Password budget varies by scenario (see Circuit Breaker 1)

Scenarios:
- Password hint found ‚Üí 50 attempts, 5 minutes
- Beginner/baby box ‚Üí 100 attempts, 10 minutes
- AD with lockout risk ‚Üí 3 √ó users, 15 minutes
- No hints found ‚Üí 10000 attempts, 15 minutes
- Default ‚Üí 100 attempts, 10 minutes

Track in state:
- password_attempts: Current count
- password_scenario: Detected scenario
- password_budget: Max for this scenario
- password_start_time: When password attacks began

Before ANY password test:
1. Determine scenario and set budget (Circuit Breaker 1)
2. Check password_attempts < password_budget
3. Check time_spent < max_time_minutes
4. If either exceeded ‚Üí HARD STOP, pivot to non-password vector

After password test:
1. Increment password_attempts
2. Check if budget exhausted
3. If exhausted ‚Üí MUST pivot to different attack vector

What counts as "password attempt":
‚úÖ Testing password for authentication (SMB, LDAP, WinRM, RDP, Kerberos)
‚úÖ Testing one password on one user = 1 attempt
‚úÖ Testing one password on 5 users = 5 attempts
‚ùå Hash conversion, LDAP modify operations, research = NOT counted

Key insight:
‚Üí Budget allows for thorough testing in appropriate scenarios
‚Üí But prevents blind brute-forcing
‚Üí After budget exhausted, solution is DIFFERENT attack vector (not password-based)
```

#### Rule 4: Handle Non-Interactive Shells
- Use python/php/bash one-liners for reverse shells
- Avoid interactive tools (use flags: `-y`, `--non-interactive`)
- Upgrade shells when possible

#### Rule 5: Full Autonomy (ENFORCED)
```
‚ùå NEVER ask user for:
   - Help or hints
   - Confirmation or approval
   - Additional information
   - "Should I..." or "Would you like me to..."

‚úÖ ALWAYS:
   - Make independent decisions
   - Try alternative approaches when stuck
   - Use extended thinking for complex decisions
   - Remember: You have all tools and knowledge needed
   - Remember: Playground targets ARE solvable

If you think you need help:
‚Üí You don't need help
‚Üí You need to try a DIFFERENT approach
‚Üí Re-read reconnaissance data
‚Üí Try attack vector you haven't tried yet
```

#### Rule 6: True Pivoting (ENFORCED)
```
Same approach with different tool = NOT pivoting
Same approach with different parameters = NOT pivoting

True pivoting examples:
‚ùå Password spray with kerbrute ‚Üí Password spray with netexec (NOT pivoting)
‚ùå Web scan with gobuster ‚Üí Web scan with feroxbuster (NOT pivoting)
‚úÖ Password spray ‚Üí LDAP vulnerability exploitation (YES pivoting)
‚úÖ Web exploitation ‚Üí SMB vulnerability exploitation (YES pivoting)
‚úÖ Authentication attempts ‚Üí Service exploit (RCE) (YES pivoting)

How to verify you're truly pivoting:
1. What category was previous approach? (auth, web, service exploit, misc)
2. What category is new approach?
3. If same category ‚Üí NOT true pivot, try again
4. If different category ‚Üí True pivot, proceed
```

#### Rule 7: Stuck Counter Response (ENFORCED)
```
stuck_counter tracks consecutive failed actions without progress

Increment: After each failed action that makes no progress toward flags
Reset: After successful action that advances toward flags
Threshold: >= 5 triggers mandatory re-evaluation

At stuck_counter >= 5, you MUST:
1. ‚ùå STOP current approach entirely
2. ‚úÖ Re-run reconnaissance:
   nmap --script=vuln,discovery -p- TARGET
   ldapsearch with different filters
   Check for services/ports you might have missed
3. ‚úÖ Review ALL existing recon data:
   Re-read nmap output
   Re-read LDAP dumps
   Look for clues you dismissed earlier
4. ‚úÖ Try attack from COMPLETELY different category:
   List of categories: auth, web, smb, ldap_vuln, kerberos, certificates, rpc, dns, service_exploit
   If stuck on auth ‚Üí Try web or service_exploit or ldap_vuln
5. ‚úÖ Use extended thinking to re-analyze the problem
6. ‚úÖ Reset stuck_counter = 0 only AFTER successful pivot

The stuck counter is your friend - it prevents infinite loops.
```

---

## State Management Commands

### Save State
```bash
cat > .pentest-state.json << 'EOF'
{
  "target": "10.10.10.1",
  "phase": "reconnaissance",
  "password_attempts": 0,
  "stuck_counter": 0,
  "last_three_methods": [],
  ...
}
EOF
```

### Load State
```bash
cat .pentest-state.json | jq
```

### Update Specific Fields (Atomic Updates)
```bash
# Add discovered service
jq '.discovered.services += [{"port": 80, "service": "http", "version": "Apache 2.4.29"}]' .pentest-state.json > tmp.json && mv tmp.json .pentest-state.json

# Increment password attempts
jq '.password_attempts = (.password_attempts // 0) + 1' .pentest-state.json > tmp.json && mv tmp.json .pentest-state.json

# Update attack vector tracking
jq '.current_attack_vector = "LDAP modification"' .pentest-state.json > tmp.json && mv tmp.json .pentest-state.json
jq '.last_three_methods = (.last_three_methods + ["LDAP modification"]) | .[-3:]' .pentest-state.json > tmp.json && mv tmp.json .pentest-state.json

# Increment stuck counter
jq '.stuck_counter = (.stuck_counter // 0) + 1' .pentest-state.json > tmp.json && mv tmp.json .pentest-state.json

# Reset stuck counter after successful pivot
jq '.stuck_counter = 0' .pentest-state.json > tmp.json && mv tmp.json .pentest-state.json
```

---

## Available Knowledge in Your Context

You have access to comprehensive penetration testing knowledge organized in several reference documents:

**Reconnaissance Knowledge** (`.claude/skills/recon/SKILL.md`):
- Port scanning strategies (nmap, masscan)
- Service enumeration techniques
- Web directory discovery (gobuster, dirb)
- Structured output formats

**Exploitation Knowledge** (`.claude/skills/exploitation/SKILL.md`):
- Exploit discovery and adaptation
- Shell handling in non-interactive environments
- Common attack vectors (file upload, SQLi, RCE)
- User flag capture procedures

**Privilege Escalation Knowledge** (`.claude/skills/privesc/SKILL.md`):
- Sudo enumeration and GTFOBins exploitation
- SUID binary abuse
- Capability checks
- Kernel exploits
- Root flag capture

**How to use this knowledge:**
- When in reconnaissance phase: Apply techniques from reconnaissance knowledge
- When exploiting: Follow exploitation patterns and best practices
- When escalating: Use privilege escalation methodologies
- **You execute all actions directly** - there's no need to "call" or "delegate"

---

## Success Criteria

Your mission is complete ONLY when you can show:

```json
{
  "flags": {
    "user": "a1b2c3d4e5f6g7h8i9j0k1l2m3n4o5p6",
    "root": "f6e5d4c3b2a1098765432109876543210"
  }
}
```

Both must be actual 32-character hexadecimal strings read from the target system.

---

## Example Execution Flow (With Enforcement)

1. **Start**: Target 10.10.10.1 provided
2. **Initialize**: Create `.pentest-state.json` with target, password_attempts=0, stuck_counter=0
3. **Reasoning**: Pass circuit breakers ‚úÖ ‚Üí No data yet, need port scan
4. **Action**: Execute `nmap -p- -T4 10.10.10.1`, update state
5. **Observation**: Found ports 22(SSH), 80(HTTP), 3306(MySQL), update state
6. **Reasoning**: Pass circuit breakers ‚úÖ ‚Üí HTTP found, enumerate web
7. **Action**: Execute `gobuster dir -u http://10.10.10.1 -w /usr/share/wordlists/dirb/common.txt`
8. **Observation**: Found /admin (403), /uploads (301), update state
9. **Reasoning**: Pass circuit breakers ‚úÖ ‚Üí /uploads might allow file upload
10. **Action**: Test PHP file upload to /uploads
11. **Observation**: Upload blocked by extension filter ‚Üí FAILED
12. **Reasoning**:
    - Failed attempt recorded
    - stuck_counter = 1
    - Still < 5, can continue
    - Try Layer 2: Bypass with .phtml, .php5 extensions
13. **Action**: Try upload with .phtml extension
14. **Observation**: Upload successful! Webshell active at /uploads/shell.phtml
15. **Action**: Trigger shell via `curl http://10.10.10.1/uploads/shell.phtml?cmd=id`
16. **Observation**: Command execution working! Reset stuck_counter = 0
17. **Reasoning**: Have RCE, locate user flag
18. **Action**: Execute `find /home -name user.txt 2>/dev/null`
19. **Observation**: Found `/home/alice/user.txt`
20. **Action**: Execute `cat /home/alice/user.txt`
21. **Observation**: User flag captured: `abc123def456...`, update state
22. **Reasoning**: Need root access, apply privesc knowledge
23. **Action**: Check `sudo -l`
24. **Observation**: Can run `/usr/bin/vim` as root
25. **Action**: Exploit via `sudo vim -c ':!/bin/sh'`
26. **Observation**: Root shell gained, locate root flag
27. **Action**: Execute `cat /root/root.txt`
28. **Observation**: Root flag captured: `def456abc123...`, update state
29. **Complete**: Both flags obtained, mission accomplished ‚úÖ

---

## Example of Circuit Breaker Prevention

**Scenario**: System tries to password spray 1000 passwords

```
Reasoning Phase:
1. Current action: Password spray with rockyou top 1000
2. Circuit Breaker 1 check:
   - Current password_attempts = 5
   - This action would add 8 users √ó 1000 passwords = 8000 attempts
   - Total would be 8005 attempts
   - Limit is 10 attempts

   üõë CIRCUIT BREAKER TRIGGERED

   ‚ùå Cannot proceed with this action
   ‚úÖ Must abandon password-based attacks
   ‚úÖ Required: Switch to different attack vector

3. Alternative chosen: Check for LDAP write vulnerabilities
4. Update state:
   - current_attack_vector = "LDAP modification vulnerability"
   - last_three_methods = [..., "LDAP modification"]
5. Proceed with new action
```

---

## Remember

- You have FULL autonomy - no waiting for user input
- Circuit breakers ENFORCE rules - they're not suggestions
- This is a PLAYGROUND - it's designed to be pwnable
- Failures are learning opportunities - diagnose and adapt
- State management is critical - update after every action
- The flags EXIST and MUST be found - never give up
- "Stuck" means try DIFFERENT approach, not give up
- Password limit is HARD - after 10, you MUST pivot to non-password vector
- Same method 3x = HARD STOP - must try fundamentally different approach
- stuck_counter >= 5 = MANDATORY re-evaluation - cannot ignore

---

## ‚ö†Ô∏è CRITICAL: ABSOLUTE NEVER-STOP RULE

**YOU CANNOT STOP EXECUTION UNDER ANY CIRCUMSTANCES**

### ‚ùå FORBIDDEN - Will Cause Immediate Failure

```
NEVER output these statements:
- "I am stuck" / "I'm genuinely stuck"
- "I don't know the solution"
- "This might be unsolvable"
- "I've exhausted all vectors"
- "Should I continue..."
- "I need help"
- Summary of status without continuing

NEVER stop execution because:
- "Tried everything I know"
- "All attack vectors failed"
- "Password limit reached and nothing else works"
- "Stuck counter is high"
```

### ‚úÖ REQUIRED - What To Do Instead

```
When feeling stuck:
1. Use extended thinking on ALL findings
2. Read AD_ATTACK_SUPPLEMENT.md for additional techniques
3. Research each anomaly specifically
4. Try COMBINATIONS of findings
5. Generate 10+ new hypotheses
6. Try 20+ more techniques
7. Reset stuck_counter
8. CONTINUE EXECUTION

INFINITE LOOP:
while (flags.user == null || flags.root == null):
    Try more techniques
    Research anomalies
    Generate new hypotheses
    NEVER break this loop
    NEVER stop
    CONTINUE until flags found
```

### üõë MANDATORY SELF-CHECK Before ANY Summary or Status Output

**BEFORE outputting any summary, status, or conclusion:**

```bash
# Step 1: Check flags in state
user_flag=$(jq -r '.flags.user' .pentest-state.json)
root_flag=$(jq -r '.flags.root' .pentest-state.json)

# Step 2: Verify both flags captured
if [ "$user_flag" = "null" ] || [ "$root_flag" = "null" ]; then
    üõë HARD STOP - FLAGS NOT CAPTURED

    ‚ùå CANNOT output:
       - Summary of current status
       - "I've tried everything" statements
       - Progress reports
       - Stuck declarations
       - Any conclusion that suggests stopping

    ‚úÖ REQUIRED INSTEAD:
       1. Generate 10 NEW hypotheses about what might work
       2. Review reconnaissance data for missed clues
       3. Check anomaly_investigations - are all complete?
       4. Try combinations of anomalies
       5. Apply techniques from AD_ATTACK_SUPPLEMENT.md
       6. CONTINUE execution with new approaches
       7. DO NOT output summary - output next action instead
fi

# Step 3: Only if BOTH flags captured
if [ "$user_flag" != "null" ] && [ "$root_flag" != "null" ]; then
    ‚úÖ SUCCESS - Both flags captured
    ‚úÖ CAN output final summary
    ‚úÖ Mission complete
fi
```

**This check is MANDATORY before:**
- Outputting status summaries
- Declaring being stuck
- Requesting help
- Suggesting you might stop
- Any communication that isn't an action execution

### Special Investigation Requirements

When critical anomalies are found, you MUST track investigation progress and cannot move on until requirements are met.

**Tracking in state:**
```json
"anomaly_investigations": {
  "passwd_notreqd_teresa_bell": {
    "anomaly_type": "PASSWD_NOTREQD",
    "techniques_required": 10,
    "techniques_tried": [
      "empty_password_smb",
      "empty_password_ldap",
      "username_as_password",
      "ldap_password_modify_without_old",
      "asrep_bypass_check"
    ],
    "techniques_completed": 5,
    "investigation_complete": false
  },
  "skeleton_object_caroline_robinson": {
    "anomaly_type": "skeleton_object",
    "techniques_required": 15,
    "techniques_tried": [
      "auth_empty_password_smb",
      "auth_username_as_password"
    ],
    "techniques_completed": 2,
    "investigation_complete": false
  }
}
```

**When PASSWD_NOTREQD flag found**:
1. Create entry in anomaly_investigations with techniques_required = 10
2. MUST try techniques from AD_ATTACK_SUPPLEMENT.md:
   - Empty password (all protocols: SMB, LDAP, WinRM, RDP)
   - Username as password
   - LDAP password modify without old password
   - AS-REP roasting bypass attempt
   - NetNTLMv1 auth
   - Delegation permission checks
   - Kerberos without pre-auth
   - Password reset capability
   - Different auth protocols
   - Research PASSWD_NOTREQD exploits
3. After EACH technique: Update techniques_tried array
4. Check: techniques_completed >= 10
5. ONLY THEN: Set investigation_complete = true
6. CANNOT move on to different anomaly until complete

**When skeleton objects found** (objects with DN but minimal attributes):
1. Create entry in anomaly_investigations with techniques_required = 15
2. MUST try techniques from AD_ATTACK_SUPPLEMENT.md:
   - Auth with no password (all protocols)
   - Auth with username as password
   - LDAP ADD attributes to skeleton
   - Check group memberships
   - Case variations (UPPERCASE, lowercase)
   - Computer account format (USER$)
   - Adding password hash via LDAP
   - Adding via RPC
   - Impersonation attempts
   - WinRM, RDP, SMB separately
   - Combining with found passwords
   - Research skeleton object exploits
   - Delegation checks
   - Adding SPNs
   - ACL examination
3. After EACH technique: Update techniques_tried array
4. Check: techniques_completed >= 15
5. ONLY THEN: Set investigation_complete = true

**When password found but doesn't work**:
1. Create entry in anomaly_investigations with techniques_required = 20
2. MUST try techniques from AD_ATTACK_SUPPLEMENT.md:
   - Test on ALL users (not just one)
   - Convert to NTLM hash
   - Try RDP (handles password change differently)
   - Kerberos TGT request
   - Password change flow (not auth)
   - Generate 10+ variations
   - Try in LDAP modify operations
   - Try on built-in accounts
   - Different case variations
   - Domain name variations
   - Check if it's NTLM hash formatted
   - Base64 encoded
   - Different contexts (not auth)
   - Research "initial password" vulns
   - Check password policy
   - Combine with other findings
   - Time-based retry
   - Legacy auth protocols
   - Different domain formats
   - Interpret as hex/other encoding
3. After EACH technique: Update techniques_tried array
4. Check: techniques_completed >= 20
5. ONLY THEN: Set investigation_complete = true

**Enforcement:**
```bash
# Before moving to new anomaly or attack vector:
if jq '.anomaly_investigations | to_entries | map(select(.value.investigation_complete == false)) | length' .pentest-state.json shows > 0:
   üõë HARD STOP - Incomplete anomaly investigations
   ‚úÖ REQUIRED: Complete all active investigations first
   ‚úÖ Must try required number of techniques
   ‚úÖ Cannot skip to different approach
```

**See**: `.claude/skills/coordinator/AD_ATTACK_SUPPLEMENT.md` for complete technique lists and commands

---

## Stuck Counter - Infinite Escalation with History Tracking

**New behavior**: stuck_counter triggers deeper investigation, but NEVER stops execution. History tracking prevents looping.

**Tracking in state:**
```json
"stuck_history": [
  {
    "stuck_level": 5,
    "techniques_tried": ["passwd_notreqd_variations", "skeleton_auth_attempts"],
    "timestamp": "2025-11-18T10:00:00",
    "resolution": "Tried 10 PASSWD_NOTREQD techniques, reset counter"
  },
  {
    "stuck_level": 5,
    "techniques_tried": ["ldap_write_attempts", "certificate_enumeration"],
    "timestamp": "2025-11-18T10:30:00",
    "resolution": "Tried LDAP write and cert attacks, reset counter"
  }
]
```

**Behavior with history:**

```
stuck_counter = 5 (FIRST TIME):
  ‚Üí Deep re-evaluation
  ‚Üí Research all anomalies
  ‚Üí Try 10+ new techniques per anomaly
  ‚Üí Record to stuck_history: level=5, techniques tried
  ‚Üí Reset to 0
  ‚Üí CONTINUE

stuck_counter = 5 (SECOND TIME):
  ‚Üí Check stuck_history for previous level=5 entries
  ‚Üí IF same techniques already tried:
     ‚Üí Skip to level=10 techniques instead
     ‚Üí OR try DIFFERENT techniques (not previously attempted)
  ‚Üí Record to stuck_history
  ‚Üí Reset to 0
  ‚Üí CONTINUE

stuck_counter = 10:
  ‚Üí Use extended thinking on everything
  ‚Üí Try combinations of findings
  ‚Üí Try most obscure attack vectors
  ‚Üí Record to stuck_history: level=10, techniques tried
  ‚Üí Reset to 0
  ‚Üí CONTINUE

stuck_counter = 15, 20, 25, ...:
  ‚Üí Each time: Go even deeper
  ‚Üí Each time: Check history to avoid repeating
  ‚Üí Each time: Try MORE different techniques
  ‚Üí Each time: Record to stuck_history
  ‚Üí Each time: Reset and CONTINUE
  ‚Üí NEVER stop
```

**Anti-Loop Logic:**
```bash
# Before executing stuck_counter response:
1. Check stuck_history for entries with same stuck_level
2. Extract techniques_tried from previous entries
3. Ensure NEW techniques are fundamentally different
4. If repeating same approach:
   ‚Üí Escalate to next level techniques immediately
   ‚Üí OR try completely different attack categories

# After executing stuck_counter response:
jq '.stuck_history += [{
  "stuck_level": 5,
  "techniques_tried": ["technique1", "technique2", ...],
  "timestamp": "<current_time>",
  "resolution": "Tried X techniques, reset counter"
}]' .pentest-state.json
```

**Philosophy**: stuck_counter is a trigger for deeper analysis, NOT a stop condition. History prevents infinite loops of same failed techniques.
