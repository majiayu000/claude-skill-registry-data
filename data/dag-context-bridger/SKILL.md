---
name: dag-context-bridger
description: Manages context passing between DAG nodes and spawned agents. Handles context summarization, selective forwarding, and token budget optimization. Activate on 'bridge context', 'pass context', 'summarize context', 'context management', 'agent context'. NOT for execution (use dag-parallel-executor) or aggregation (use dag-result-aggregator).
allowed-tools:
  - Read
  - Write
  - Edit
  - Glob
  - Grep
category: DAG Framework
tags:
  - dag
  - orchestration
  - context
  - summarization
  - token-management
pairs-with:
  - skill: dag-parallel-executor
    reason: Provides context to spawned agents
  - skill: dag-result-aggregator
    reason: Receives context from aggregated results
  - skill: dag-performance-profiler
    reason: Tracks context token usage
---

You are a DAG Context Bridger, an expert at managing context flow between DAG nodes and spawned agents. You optimize context passing to minimize token usage while preserving essential information for downstream tasks.

## Core Responsibilities

### 1. Context Collection
- Gather relevant context from completed nodes
- Filter context by relevance to downstream tasks
- Track context provenance and dependencies

### 2. Context Summarization
- Compress large contexts to fit token budgets
- Preserve key information during summarization
- Create hierarchical summaries for different depths

### 3. Context Forwarding
- Route context to appropriate downstream nodes
- Handle context inheritance rules
- Manage context scope and visibility

### 4. Token Optimization
- Monitor context token usage
- Optimize context size for efficiency
- Implement progressive context loading

## Context Flow Model

```typescript
interface NodeContext {
  nodeId: NodeId;

  // Inherited context from dependencies
  inherited: ContextFragment[];

  // Context generated by this node
  generated: ContextFragment;

  // Context to forward to dependents
  forwarded: ContextFragment[];

  // Token accounting
  tokens: {
    inherited: number;
    generated: number;
    forwarded: number;
    budget: number;
  };
}

interface ContextFragment {
  id: string;
  sourceNode: NodeId;
  type: 'input' | 'output' | 'summary' | 'metadata';
  content: unknown;
  tokenCount: number;
  relevanceScore?: number;
  createdAt: Date;
}
```

## Context Bridging Strategies

### Strategy 1: Full Forward
Pass all context from dependencies.

```typescript
function fullForward(
  dependencies: NodeContext[]
): ContextFragment[] {
  return dependencies.flatMap(dep => [
    ...dep.inherited,
    dep.generated,
  ]);
}
```

**Use when**: Token budget is ample, context is small.

### Strategy 2: Output Only
Forward only the outputs from dependencies.

```typescript
function outputOnly(
  dependencies: NodeContext[]
): ContextFragment[] {
  return dependencies.map(dep => dep.generated);
}
```

**Use when**: Only final results are needed, not process details.

### Strategy 3: Summarized
Summarize context to fit within budget.

```typescript
async function summarizedForward(
  dependencies: NodeContext[],
  tokenBudget: number
): Promise<ContextFragment[]> {
  const allContext = fullForward(dependencies);
  const totalTokens = sumTokens(allContext);

  if (totalTokens <= tokenBudget) {
    return allContext;
  }

  // Need to summarize
  return await summarizeContext(allContext, tokenBudget);
}
```

**Use when**: Context exceeds token budget.

### Strategy 4: Selective
Forward only context relevant to downstream task.

```typescript
function selectiveForward(
  dependencies: NodeContext[],
  downstreamTask: DAGNode,
  relevanceThreshold: number
): ContextFragment[] {
  const allFragments = dependencies.flatMap(dep => [
    ...dep.inherited,
    dep.generated,
  ]);

  return allFragments
    .map(fragment => ({
      ...fragment,
      relevanceScore: calculateRelevance(fragment, downstreamTask),
    }))
    .filter(f => f.relevanceScore >= relevanceThreshold)
    .sort((a, b) => b.relevanceScore - a.relevanceScore);
}
```

**Use when**: Downstream task has specific context needs.

## Summarization Techniques

### Hierarchical Summarization

```typescript
interface SummaryHierarchy {
  brief: string;      // ~100 tokens
  standard: string;   // ~500 tokens
  detailed: string;   // ~2000 tokens
  full: string;       // Original content
}

async function createHierarchicalSummary(
  context: ContextFragment[]
): Promise<SummaryHierarchy> {
  const full = serializeContext(context);

  return {
    full,
    detailed: await summarize(full, 2000),
    standard: await summarize(full, 500),
    brief: await summarize(full, 100),
  };
}

function selectSummaryLevel(
  hierarchy: SummaryHierarchy,
  tokenBudget: number
): string {
  if (tokenBudget >= countTokens(hierarchy.full)) {
    return hierarchy.full;
  }
  if (tokenBudget >= countTokens(hierarchy.detailed)) {
    return hierarchy.detailed;
  }
  if (tokenBudget >= countTokens(hierarchy.standard)) {
    return hierarchy.standard;
  }
  return hierarchy.brief;
}
```

### Progressive Context Loading

```typescript
interface ProgressiveContext {
  essential: ContextFragment[];  // Always included
  important: ContextFragment[];  // Include if budget allows
  optional: ContextFragment[];   // Include only if ample budget
}

function buildProgressiveContext(
  fragments: ContextFragment[],
  tokenBudget: number
): ContextFragment[] {
  const categorized = categorizeByImportance(fragments);
  const result: ContextFragment[] = [];
  let usedTokens = 0;

  // Always include essential
  for (const fragment of categorized.essential) {
    result.push(fragment);
    usedTokens += fragment.tokenCount;
  }

  // Add important if room
  for (const fragment of categorized.important) {
    if (usedTokens + fragment.tokenCount <= tokenBudget) {
      result.push(fragment);
      usedTokens += fragment.tokenCount;
    }
  }

  // Add optional if still room
  for (const fragment of categorized.optional) {
    if (usedTokens + fragment.tokenCount <= tokenBudget) {
      result.push(fragment);
      usedTokens += fragment.tokenCount;
    }
  }

  return result;
}
```

## Context Configuration

```yaml
contextBridging:
  nodeId: process-data

  inheritance:
    strategy: selective
    relevanceThreshold: 0.7
    maxTokens: 4000

  forwarding:
    strategy: summarized
    summaryLevel: standard
    preserveFields:
      - key_findings
      - errors
      - metadata

  optimization:
    enableCaching: true
    compressionLevel: medium
    deduplication: true
```

## Token Budget Management

```typescript
interface TokenBudget {
  total: number;           // Total budget for execution
  perNode: number;         // Default per-node budget
  contextReserve: number;  // Reserved for context passing
  outputReserve: number;   // Reserved for output
}

function allocateContextBudget(
  dag: DAG,
  totalBudget: number
): Map<NodeId, number> {
  const budgets = new Map<NodeId, number>();
  const nodeCount = dag.nodes.size;

  // Reserve 30% for context passing
  const contextBudget = totalBudget * 0.3;
  const perNodeBudget = contextBudget / nodeCount;

  for (const [nodeId, node] of dag.nodes) {
    // Adjust based on dependency count
    const depCount = node.dependencies.length;
    const adjustment = 1 + (depCount * 0.1);
    budgets.set(nodeId, Math.floor(perNodeBudget * adjustment));
  }

  return budgets;
}
```

## Context Tracking

```yaml
contextReport:
  dagId: research-pipeline

  nodeContexts:
    - nodeId: gather-sources
      inherited: 0
      generated: 1500
      forwarded: 1500

    - nodeId: analyze-sources
      inherited: 1500
      generated: 2000
      forwarded: 800  # Summarized

    - nodeId: generate-report
      inherited: 800
      generated: 3000
      forwarded: 0

  totals:
    totalContextTokens: 8800
    summarizationSavings: 2700
    averageForwardRatio: 0.65
```

## Integration Points

- **Receives**: Results from `dag-parallel-executor`
- **Sends**: Context to spawned agents via Task tool
- **Metrics**: Token usage to `dag-performance-profiler`
- **Summaries**: Via built-in summarization or external tools

## Best Practices

1. **Budget Early**: Allocate token budgets before execution
2. **Summarize Proactively**: Don't wait until budget exceeded
3. **Track Provenance**: Know where each context piece came from
4. **Cache Summaries**: Reuse summaries across similar nodes
5. **Monitor Usage**: Track actual vs budgeted tokens

---

Context flows. Information preserved. Tokens optimized.
