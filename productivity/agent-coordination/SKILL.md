---
name: agent-coordination
description: Coordinate multiple agents for software development across any language. Use for parallel execution of independent tasks, sequential chains with dependencies, swarm analysis from multiple perspectives, or iterative refinement loops. Handles Python, JavaScript, Java, Go, Rust, C#, and other languages.
---

# Agent Coordination

Coordinate multiple agents efficiently for complex development tasks across any programming language.

## Quick Start

Choose your coordination strategy:

**Parallel** - Independent tasks → See [PARALLEL.md](PARALLEL.md)
**Sequential** - Dependent tasks → See [SEQUENTIAL.md](SEQUENTIAL.md)  
**Swarm** - Multi-perspective analysis → See [SWARM.md](SWARM.md)
**Hybrid** - Multi-phase workflows → See [HYBRID.md](HYBRID.md)
**Iterative** - Progressive refinement → See [ITERATIVE.md](ITERATIVE.md)

## Available Agents

| Agent | Best For |
|-------|----------|
| code-reviewer | Quality assessment, standards |
| test-runner | Execute tests, verify functionality |
| feature-implementer | Build new capabilities |
| refactorer | Improve existing code |
| debugger | Diagnose and fix issues |
| security-auditor | Find vulnerabilities |
| performance-optimizer | Speed and efficiency |
| loop-agent | Orchestrate iterations |

## Basic Workflow

1. **Choose strategy** based on task structure
2. **Select agents** matching required capabilities
3. **Execute** with quality gates between phases
4. **Validate** outputs before proceeding
5. **Synthesize** results

## Language Support

This coordination skill works with:
- Python (Django, Flask, FastAPI)
- JavaScript/TypeScript (Node.js, React, Vue)
- Java (Spring, Jakarta EE)
- Go (Gin, Echo)
- Rust (Actix, Rocket)
- C# (.NET, ASP.NET Core)

## Common Patterns

**Analysis + Execution**:
```
1. Swarm analysis (parallel agents gather insights)
2. Sequential execution (apply findings)
3. Parallel validation (verify results)
```

**Test-Driven Workflow**:
```
1. test-runner: Run existing tests
2. feature-implementer: Add functionality
3. test-runner: Verify implementation
4. code-reviewer: Quality check
```

**Performance Optimization**:
```
Loop with performance-optimizer until:
- Metrics meet targets
- No more optimizations found
- Max iterations reached
```

## Quality Gates

Between each phase, verify:
- Code compiles/parses correctly
- Tests pass with adequate coverage
- Security scans clean
- Performance acceptable
- No regressions introduced

## Next Steps

Read the specific coordination pattern that matches your task structure. Each pattern includes detailed workflows, examples, and quality criteria.