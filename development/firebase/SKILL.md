---
name: Firebase
description: Google's mobile and web application development platform.
---

# Firebase Skill

Google's mobile and web application development platform., generated from official documentation.

## When to Use This Skill

This skill should be triggered when:
- Working with Firebase
- Asking about Firebase features or APIs
- Implementing Firebase solutions
- Debugging Firebase code
- Learning Firebase best practices

## Quick Reference

### Common Patterns

**Pattern 1:** Firebase Local Emulator Suite provides a rich user interface that includes support for viewing emulator logs. You can filter logs in the Emulator Suite UI using the query syntax described on this page. The logs query language supports exact comparisons and and operations. Other operations are not currently supported. Quotes are generally optional, except when using spaces or newlines. Note this query syntax is available in Emulator Suite UI only. Emulators output additional logs in the *-debug.log files in your project directory (e.g., firestore-debug.log). // Find only info logs. level=info //Find logs for the sayHelloWorld function metadata.emulator.name=functions metadata.function.name=sayHelloWorld //Find any log mentioning "hello world" hello world // turns into search="hello world" internally //Return any Hosting POST requests metadata.emulator.name=hosting search=POST Keywords level Log level. One of warn, info, error. search Text to match in a fuzzy search. For example, search=abc returns logs with the text "abc". Use the search keyword to combine fuzzy searches with other keyword searches using the and operator. metadata Query on a specific emulator or on a function name. metadata.emulator.name Query logs from a specified emulator. One of firestore, functions, database, pubsub, hosting, storage. metadata.function.name The function name as defined in user app code. user Any JSON data the user logged from in-app code, for example: console.log(JSON.stringify({hello: world})) The above log output can be queried with user.hello.

```
and
```

**Pattern 2:** Any JSON data the user logged from in-app code, for example:

```
console.log(JSON.stringify({hello: world}))
```

**Pattern 3:** Schema @available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *) public final class Schema : Sendable extension Schema: Encodable A Schema object allows the definition of input and output data types. These types can be objects, but also primitives and arrays. Represents a select subset of an OpenAPI 3.0 schema object. StringFormat Modifiers describing the expected format of a string Schema. Declaration Swift @available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *) public struct StringFormat : EncodableProtoEnum IntegerFormat Modifiers describing the expected format of an integer Schema. Declaration Swift @available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *) public struct IntegerFormat : EncodableProtoEnum, Sendable type The data type. Declaration Swift public var type: String { get } format The format of the data. Declaration Swift public let format: String? description A human-readable explanation of the purpose of the schema or property. While not strictly enforced on the value itself, good descriptions significantly help the model understand the context and generate more relevant and accurate output. Declaration Swift public let description: String? title A human-readable name/summary for the schema or a specific property. This helps document the schema’s purpose but doesn’t typically constrain the generated value. It can subtly guide the model by clarifying the intent of a field. Declaration Swift public let title: String? nullable Indicates if the value may be null. Declaration Swift public let nullable: Bool? enumValues Possible values of the element of type “STRING” with “enum” format. Declaration Swift public let enumValues: [String]? items Defines the schema for the elements within the "ARRAY". All items in the generated array must conform to this schema definition. This can be a simple type (like .string) or a complex nested object schema. Declaration Swift public let items: Schema? minItems An integer specifying the minimum number of items the generated "ARRAY" must contain. Declaration Swift public let minItems: Int? maxItems An integer specifying the maximum number of items the generated "ARRAY" must contain. Declaration Swift public let maxItems: Int? minimum The minimum value of a numeric type. Declaration Swift public let minimum: Double? maximum The maximum value of a numeric type. Declaration Swift public let maximum: Double? properties Defines the members (key-value pairs) expected within an object. It’s a dictionary where keys are the property names (strings) and values are nested Schema definitions describing each property’s type and constraints. Declaration Swift public let properties: [String : Schema]? anyOf An array of Schema objects. The generated data must be valid against any (one or more) of the schemas listed in this array. This allows specifying multiple possible structures or types for a single field. For example, a value could be either a String or an Integer: Schema.anyOf(schemas: [.string(), .integer()]) Declaration Swift public let anyOf: [Schema]? requiredProperties An array of strings, where each string is the name of a property defined in the properties dictionary that must be present in the generated object. If a property is listed here, the model must include it in the output. Declaration Swift public let requiredProperties: [String]? propertyOrdering A specific hint provided to the Gemini model, suggesting the order in which the keys should appear in the generated JSON string. Important: Standard JSON objects are inherently unordered collections of key-value pairs. While the model will try to respect propertyOrdering in its textual JSON output, subsequent parsing into native Swift objects (like Dictionaries or Structs) might not preserve this order. This parameter primarily affects the raw JSON string serialization. Declaration Swift public let propertyOrdering: [String]? string(description:title:nullable:format:) Returns a Schema representing a string value. This schema instructs the model to produce data of type "STRING", which is suitable for decoding into a Swift String (or String?, if nullable is set to true). Tip If a specific set of string values should be generated by the model (for example, “north”, “south”, “east”, or “west”), use enumeration(values:description:nullable:) instead to constrain the generated values. Declaration Swift public static func string(description: String? = nil, title: String? = nil, nullable: Bool = false, format: StringFormat? = nil) -> Schema Parameters description An optional description of what the string should contain or represent; may use Markdown format. title An optional human-readable name/summary for the schema. nullable If true, instructs the model that it may generate null instead of a string; defaults to false, enforcing that a string value is generated. format An optional modifier describing the expected format of the string. Currently no formats are officially supported for strings but custom values may be specified using custom(_:), for example .custom("email") or .custom("byte"); these provide additional hints for how the model should respond but are not guaranteed to be adhered to. enumeration(values:description:title:nullable:) Returns a Schema representing an enumeration of string values. This schema instructs the model to produce data of type "STRING" with the format "enum". This data is suitable for decoding into a Swift String (or String?, if nullable is set to true), or an enum with strings as raw values. Example: The values ["north", "south", "east", "west"] for an enumeration of directions. enum Direction: String, Decodable { case north, south, east, west } Declaration Swift public static func enumeration(values: [String], description: String? = nil, title: String? = nil, nullable: Bool = false) -> Schema Parameters values The list of string values that may be generated by the model. description An optional description of what the values contain or represent; may use Markdown format. title An optional human-readable name/summary for the schema. nullable If true, instructs the model that it may generate null instead of one of the strings specified in values; defaults to false, enforcing that one of the string values is generated. float(description:title:nullable:minimum:maximum:) Returns a Schema representing a single-precision floating-point number. This schema instructs the model to produce data of type "NUMBER" with the format "float", which is suitable for decoding into a Swift Float (or Float?, if nullable is set to true). Important This Schema provides a hint to the model that it should generate a single-precision floating-point number, a float, but only guarantees that the value will be a number. Declaration Swift public static func float(description: String? = nil, title: String? = nil, nullable: Bool = false, minimum: Float? = nil, maximum: Float? = nil) -> Schema Parameters description An optional description of what the number should contain or represent; may use Markdown format. title An optional human-readable name/summary for the schema. nullable If true, instructs the model that it may generate null instead of a number; defaults to false, enforcing that a number is generated. minimum If specified, instructs the model that the value should be greater than or equal to the specified minimum. maximum If specified, instructs the model that the value should be less than or equal to the specified maximum. double(description:title:nullable:minimum:maximum:) Returns a Schema representing a floating-point number. This schema instructs the model to produce data of type "NUMBER", which is suitable for decoding into a Swift Double (or Double?, if nullable is set to true). Declaration Swift public static func double(description: String? = nil, title: String? = nil, nullable: Bool = false, minimum: Double? = nil, maximum: Double? = nil) -> Schema Parameters description An optional description of what the number should contain or represent; may use Markdown format. title An optional human-readable name/summary for the schema. nullable If true, instructs the model that it may return null instead of a number; defaults to false, enforcing that a number is returned. minimum If specified, instructs the model that the value should be greater than or equal to the specified minimum. maximum If specified, instructs the model that the value should be less than or equal to the specified maximum. integer(description:title:nullable:format:minimum:maximum:) Returns a Schema representing an integer value. This schema instructs the model to produce data of type "INTEGER", which is suitable for decoding into a Swift Int (or Int?, if nullable is set to true) or other integer types (such as Int32) based on the expected size of values being generated. Important If a format of int32 or int64 is specified, this provides a hint to the model that it should generate 32-bit or 64-bit integers but this Schema only guarantees that the value will be an integer. Therefore, it is possible that decoding into an Int32 could overflow even if a format of int32 is specified. Declaration Swift public static func integer(description: String? = nil, title: String? = nil, nullable: Bool = false, format: IntegerFormat? = nil, minimum: Int? = nil, maximum: Int? = nil) -> Schema Parameters description An optional description of what the integer should contain or represent; may use Markdown format. title An optional human-readable name/summary for the schema. nullable If true, instructs the model that it may return null instead of an integer; defaults to false, enforcing that an integer is returned. format An optional modifier describing the expected format of the integer. Currently the formats int32 and int64 are supported; custom values may be specified using custom(_:) but may be ignored by the model. minimum If specified, instructs the model that the value should be greater than or equal to the specified minimum. maximum If specified, instructs the model that the value should be less than or equal to the specified maximum. boolean(description:title:nullable:) Returns a Schema representing a boolean value. This schema instructs the model to produce data of type "BOOLEAN", which is suitable for decoding into a Swift Bool (or Bool?, if nullable is set to true). Declaration Swift public static func boolean(description: String? = nil, title: String? = nil, nullable: Bool = false) -> Schema Parameters description An optional description of what the boolean should contain or represent; may use Markdown format. title An optional human-readable name/summary for the schema. nullable If true, instructs the model that it may return null instead of a boolean; defaults to false, enforcing that a boolean is returned. array(items:description:title:nullable:minItems:maxItems:) Returns a Schema representing an array. This schema instructs the model to produce data of type "ARRAY", which has elements of any other data type (including nested "ARRAY"s). This data is suitable for decoding into many Swift collection types, including Array, holding elements of types suitable for decoding from the respective items type. Declaration Swift public static func array(items: Schema, description: String? = nil, title: String? = nil, nullable: Bool = false, minItems: Int? = nil, maxItems: Int? = nil) -> Schema Parameters items The Schema of the elements that the array will hold. description An optional description of what the array should contain or represent; may use Markdown format. title An optional human-readable name/summary for the schema. nullable If true, instructs the model that it may return null instead of an array; defaults to false, enforcing that an array is returned. minItems Instructs the model to produce at least the specified minimum number of elements in the array; defaults to nil, meaning any number. maxItems Instructs the model to produce at most the specified maximum number of elements in the array. object(properties:optionalProperties:propertyOrdering:description:title:nullable:) Returns a Schema representing an object. This schema instructs the model to produce data of type "OBJECT", which has keys of type "STRING" and values of any other data type (including nested "OBJECT"s). This data is suitable for decoding into Swift keyed collection types, including Dictionary, or other custom struct or class types. Example: A City could be represented with the following object Schema. Schema.object(properties: [ "name" : .string(), "population": .integer() ]) The generated data could be decoded into a Swift native type: struct City: Decodable { let name: String let population: Int } Declaration Swift public static func object(properties: [String: Schema], optionalProperties: [String] = [], propertyOrdering: [String]? = nil, description: String? = nil, title: String? = nil, nullable: Bool = false) -> Schema Parameters properties A dictionary containing the object’s property names as keys and their respective Schemas as values. optionalProperties A list of property names that may be be omitted in objects generated by the model; these names must correspond to the keys provided in the properties dictionary and may be an empty list. propertyOrdering An optional hint to the model suggesting the order for keys in the generated JSON string. See propertyOrdering for details. description An optional description of what the object should contain or represent; may use Markdown format. title An optional human-readable name/summary for the schema. nullable If true, instructs the model that it may return null instead of an object; defaults to false, enforcing that an object is returned. anyOf(schemas:) Returns a Schema representing a value that must conform to any (one or more) of the provided sub-schemas. This schema instructs the model to produce data that is valid against at least one of the schemas listed in the schemas array. This is useful when a field can accept multiple distinct types or structures. Example: A field that can hold either a simple user ID (integer) or a detailed user object. Schema.anyOf(schemas: [ .integer(description: "User ID"), .object(properties: [ "userId": .integer(), "userName": .string() ], description: "Detailed User Object") ]) The generated data could be decoded based on which schema it matches. Declaration Swift public static func anyOf(schemas: [Schema]) -> Schema Parameters schemas An array of Schema objects. The generated data must be valid against at least one of these schemas. The array must not be empty.

```
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
public final class Schema : Sendable
```

**Pattern 4:** StringFormat Modifiers describing the expected format of a string Schema. Declaration Swift @available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *) public struct StringFormat : EncodableProtoEnum IntegerFormat Modifiers describing the expected format of an integer Schema. Declaration Swift @available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *) public struct IntegerFormat : EncodableProtoEnum, Sendable type The data type. Declaration Swift public var type: String { get } format The format of the data. Declaration Swift public let format: String? description A human-readable explanation of the purpose of the schema or property. While not strictly enforced on the value itself, good descriptions significantly help the model understand the context and generate more relevant and accurate output. Declaration Swift public let description: String? title A human-readable name/summary for the schema or a specific property. This helps document the schema’s purpose but doesn’t typically constrain the generated value. It can subtly guide the model by clarifying the intent of a field. Declaration Swift public let title: String? nullable Indicates if the value may be null. Declaration Swift public let nullable: Bool? enumValues Possible values of the element of type “STRING” with “enum” format. Declaration Swift public let enumValues: [String]? items Defines the schema for the elements within the "ARRAY". All items in the generated array must conform to this schema definition. This can be a simple type (like .string) or a complex nested object schema. Declaration Swift public let items: Schema? minItems An integer specifying the minimum number of items the generated "ARRAY" must contain. Declaration Swift public let minItems: Int? maxItems An integer specifying the maximum number of items the generated "ARRAY" must contain. Declaration Swift public let maxItems: Int? minimum The minimum value of a numeric type. Declaration Swift public let minimum: Double? maximum The maximum value of a numeric type. Declaration Swift public let maximum: Double? properties Defines the members (key-value pairs) expected within an object. It’s a dictionary where keys are the property names (strings) and values are nested Schema definitions describing each property’s type and constraints. Declaration Swift public let properties: [String : Schema]? anyOf An array of Schema objects. The generated data must be valid against any (one or more) of the schemas listed in this array. This allows specifying multiple possible structures or types for a single field. For example, a value could be either a String or an Integer: Schema.anyOf(schemas: [.string(), .integer()]) Declaration Swift public let anyOf: [Schema]? requiredProperties An array of strings, where each string is the name of a property defined in the properties dictionary that must be present in the generated object. If a property is listed here, the model must include it in the output. Declaration Swift public let requiredProperties: [String]? propertyOrdering A specific hint provided to the Gemini model, suggesting the order in which the keys should appear in the generated JSON string. Important: Standard JSON objects are inherently unordered collections of key-value pairs. While the model will try to respect propertyOrdering in its textual JSON output, subsequent parsing into native Swift objects (like Dictionaries or Structs) might not preserve this order. This parameter primarily affects the raw JSON string serialization. Declaration Swift public let propertyOrdering: [String]? string(description:title:nullable:format:) Returns a Schema representing a string value. This schema instructs the model to produce data of type "STRING", which is suitable for decoding into a Swift String (or String?, if nullable is set to true). Tip If a specific set of string values should be generated by the model (for example, “north”, “south”, “east”, or “west”), use enumeration(values:description:nullable:) instead to constrain the generated values. Declaration Swift public static func string(description: String? = nil, title: String? = nil, nullable: Bool = false, format: StringFormat? = nil) -> Schema Parameters description An optional description of what the string should contain or represent; may use Markdown format. title An optional human-readable name/summary for the schema. nullable If true, instructs the model that it may generate null instead of a string; defaults to false, enforcing that a string value is generated. format An optional modifier describing the expected format of the string. Currently no formats are officially supported for strings but custom values may be specified using custom(_:), for example .custom("email") or .custom("byte"); these provide additional hints for how the model should respond but are not guaranteed to be adhered to. enumeration(values:description:title:nullable:) Returns a Schema representing an enumeration of string values. This schema instructs the model to produce data of type "STRING" with the format "enum". This data is suitable for decoding into a Swift String (or String?, if nullable is set to true), or an enum with strings as raw values. Example: The values ["north", "south", "east", "west"] for an enumeration of directions. enum Direction: String, Decodable { case north, south, east, west } Declaration Swift public static func enumeration(values: [String], description: String? = nil, title: String? = nil, nullable: Bool = false) -> Schema Parameters values The list of string values that may be generated by the model. description An optional description of what the values contain or represent; may use Markdown format. title An optional human-readable name/summary for the schema. nullable If true, instructs the model that it may generate null instead of one of the strings specified in values; defaults to false, enforcing that one of the string values is generated. float(description:title:nullable:minimum:maximum:) Returns a Schema representing a single-precision floating-point number. This schema instructs the model to produce data of type "NUMBER" with the format "float", which is suitable for decoding into a Swift Float (or Float?, if nullable is set to true). Important This Schema provides a hint to the model that it should generate a single-precision floating-point number, a float, but only guarantees that the value will be a number. Declaration Swift public static func float(description: String? = nil, title: String? = nil, nullable: Bool = false, minimum: Float? = nil, maximum: Float? = nil) -> Schema Parameters description An optional description of what the number should contain or represent; may use Markdown format. title An optional human-readable name/summary for the schema. nullable If true, instructs the model that it may generate null instead of a number; defaults to false, enforcing that a number is generated. minimum If specified, instructs the model that the value should be greater than or equal to the specified minimum. maximum If specified, instructs the model that the value should be less than or equal to the specified maximum. double(description:title:nullable:minimum:maximum:) Returns a Schema representing a floating-point number. This schema instructs the model to produce data of type "NUMBER", which is suitable for decoding into a Swift Double (or Double?, if nullable is set to true). Declaration Swift public static func double(description: String? = nil, title: String? = nil, nullable: Bool = false, minimum: Double? = nil, maximum: Double? = nil) -> Schema Parameters description An optional description of what the number should contain or represent; may use Markdown format. title An optional human-readable name/summary for the schema. nullable If true, instructs the model that it may return null instead of a number; defaults to false, enforcing that a number is returned. minimum If specified, instructs the model that the value should be greater than or equal to the specified minimum. maximum If specified, instructs the model that the value should be less than or equal to the specified maximum. integer(description:title:nullable:format:minimum:maximum:) Returns a Schema representing an integer value. This schema instructs the model to produce data of type "INTEGER", which is suitable for decoding into a Swift Int (or Int?, if nullable is set to true) or other integer types (such as Int32) based on the expected size of values being generated. Important If a format of int32 or int64 is specified, this provides a hint to the model that it should generate 32-bit or 64-bit integers but this Schema only guarantees that the value will be an integer. Therefore, it is possible that decoding into an Int32 could overflow even if a format of int32 is specified. Declaration Swift public static func integer(description: String? = nil, title: String? = nil, nullable: Bool = false, format: IntegerFormat? = nil, minimum: Int? = nil, maximum: Int? = nil) -> Schema Parameters description An optional description of what the integer should contain or represent; may use Markdown format. title An optional human-readable name/summary for the schema. nullable If true, instructs the model that it may return null instead of an integer; defaults to false, enforcing that an integer is returned. format An optional modifier describing the expected format of the integer. Currently the formats int32 and int64 are supported; custom values may be specified using custom(_:) but may be ignored by the model. minimum If specified, instructs the model that the value should be greater than or equal to the specified minimum. maximum If specified, instructs the model that the value should be less than or equal to the specified maximum. boolean(description:title:nullable:) Returns a Schema representing a boolean value. This schema instructs the model to produce data of type "BOOLEAN", which is suitable for decoding into a Swift Bool (or Bool?, if nullable is set to true). Declaration Swift public static func boolean(description: String? = nil, title: String? = nil, nullable: Bool = false) -> Schema Parameters description An optional description of what the boolean should contain or represent; may use Markdown format. title An optional human-readable name/summary for the schema. nullable If true, instructs the model that it may return null instead of a boolean; defaults to false, enforcing that a boolean is returned. array(items:description:title:nullable:minItems:maxItems:) Returns a Schema representing an array. This schema instructs the model to produce data of type "ARRAY", which has elements of any other data type (including nested "ARRAY"s). This data is suitable for decoding into many Swift collection types, including Array, holding elements of types suitable for decoding from the respective items type. Declaration Swift public static func array(items: Schema, description: String? = nil, title: String? = nil, nullable: Bool = false, minItems: Int? = nil, maxItems: Int? = nil) -> Schema Parameters items The Schema of the elements that the array will hold. description An optional description of what the array should contain or represent; may use Markdown format. title An optional human-readable name/summary for the schema. nullable If true, instructs the model that it may return null instead of an array; defaults to false, enforcing that an array is returned. minItems Instructs the model to produce at least the specified minimum number of elements in the array; defaults to nil, meaning any number. maxItems Instructs the model to produce at most the specified maximum number of elements in the array. object(properties:optionalProperties:propertyOrdering:description:title:nullable:) Returns a Schema representing an object. This schema instructs the model to produce data of type "OBJECT", which has keys of type "STRING" and values of any other data type (including nested "OBJECT"s). This data is suitable for decoding into Swift keyed collection types, including Dictionary, or other custom struct or class types. Example: A City could be represented with the following object Schema. Schema.object(properties: [ "name" : .string(), "population": .integer() ]) The generated data could be decoded into a Swift native type: struct City: Decodable { let name: String let population: Int } Declaration Swift public static func object(properties: [String: Schema], optionalProperties: [String] = [], propertyOrdering: [String]? = nil, description: String? = nil, title: String? = nil, nullable: Bool = false) -> Schema Parameters properties A dictionary containing the object’s property names as keys and their respective Schemas as values. optionalProperties A list of property names that may be be omitted in objects generated by the model; these names must correspond to the keys provided in the properties dictionary and may be an empty list. propertyOrdering An optional hint to the model suggesting the order for keys in the generated JSON string. See propertyOrdering for details. description An optional description of what the object should contain or represent; may use Markdown format. title An optional human-readable name/summary for the schema. nullable If true, instructs the model that it may return null instead of an object; defaults to false, enforcing that an object is returned. anyOf(schemas:) Returns a Schema representing a value that must conform to any (one or more) of the provided sub-schemas. This schema instructs the model to produce data that is valid against at least one of the schemas listed in the schemas array. This is useful when a field can accept multiple distinct types or structures. Example: A field that can hold either a simple user ID (integer) or a detailed user object. Schema.anyOf(schemas: [ .integer(description: "User ID"), .object(properties: [ "userId": .integer(), "userName": .string() ], description: "Detailed User Object") ]) The generated data could be decoded based on which schema it matches. Declaration Swift public static func anyOf(schemas: [Schema]) -> Schema Parameters schemas An array of Schema objects. The generated data must be valid against at least one of these schemas. The array must not be empty.

```
StringFormat
```

**Pattern 5:** Returns a Schema representing an enumeration of string values. This schema instructs the model to produce data of type "STRING" with the format "enum". This data is suitable for decoding into a Swift String (or String?, if nullable is set to true), or an enum with strings as raw values. Example: The values ["north", "south", "east", "west"] for an enumeration of directions. enum Direction: String, Decodable { case north, south, east, west } Declaration Swift public static func enumeration(values: [String], description: String? = nil, title: String? = nil, nullable: Bool = false) -> Schema Parameters values The list of string values that may be generated by the model. description An optional description of what the values contain or represent; may use Markdown format. title An optional human-readable name/summary for the schema. nullable If true, instructs the model that it may generate null instead of one of the strings specified in values; defaults to false, enforcing that one of the string values is generated.

```
Schema
```

**Pattern 6:** Cloud Firestore automatically creates indexes to support the most common types of queries, but allows you to define custom indexes and index overrides as described in the Cloud Firestore guides. You can create, modify and deploy custom indexes in the Firebase console, or using the CLI. From the CLI, edit your index configuration file, with default filename firestore.indexes.json, and deploy using the firebase deploy command. You can export indexes with the CLI using firebase firestore:indexes. An index configuration file defines one object containing an indexes array and an optional fieldOverrides array. Here's an example: { // Required, specify compound and vector indexes indexes: [ { collectionGroup: "posts", queryScope: "COLLECTION", fields: [ { fieldPath: "author", arrayConfig: "CONTAINS" }, { fieldPath: "timestamp", order: "DESCENDING" } ] }, { collectionGroup: "coffee-beans", queryScope: "COLLECTION", fields: [ { fieldPath: "embedding_field", vectorConfig: { dimension: 256, flat: {} } } ] } ], // Optional, disable indexes or enable single-field collection group indexes fieldOverrides: [ { collectionGroup: "posts", fieldPath: "myBigMapField", // We want to disable indexing on our big map field, and so empty the indexes array indexes: [] } ] } Deploy an index configuration Deploy your index configuration with the firebase deploy command. If you only want to deploy indexes for the databases configured in your project, add the --only firestore flag. See the options reference for this command. To list deployed indexes, run the firebase firestore:indexes command. Add the --database=<databaseID> flag to list indexes for a database other than your project's default database. If you make edits to the indexes using the Firebase console, make sure you also update your local indexes file. For more on managing indexes, see the Cloud Firestore guides. JSON format Indexes The schema for one object in the indexes array is as follows. Optional properties are identified with the ? character. Note that Cloud Firestore document fields can only be indexed in one mode, thus a field object can only contain one of the order, arrayConfig, and vectorConfig properties. While there are fields and properties that are specific to Cloud Firestore editions, some fields are shared as well. Standard edition collectionGroup: string // Labeled "Collection ID" in the Firebase console queryScope: string // One of "COLLECTION", "COLLECTION_GROUP" apiScope: string // "ANY_API" (the default) is the only acceptable value. Optional. density: string // "SPARSE_ALL" is the only acceptable value. Optional. fields: array fieldPath: string order?: string // One of "ASCENDING", "DESCENDING"; excludes arrayConfig and vectorConfig properties arrayConfig?: string // If this parameter used, must be "CONTAINS"; excludes order and vectorConfig properties vectorConfig?: object // Indicates that this is a vector index; excludes order and arrayConfig properties dimension: number // The resulting index will only include vectors of this dimension flat: {} // Indicates the vector index is a flat index Enterprise edition collectionGroup: string // Labeled "Collection ID" in the Firebase console queryScope: string // One of "COLLECTION", "COLLECTION_GROUP" apiScope: string // "MONGODB_COMPATIBLE_API" is the only acceptable value multikey: boolean // Indicates if this is a multikey index density: string // One of "SPARSE_ANY" or "DENSE" fields: array fieldPath: string order?: string // One of "ASCENDING", "DESCENDING"; excludes arrayConfig and vectorConfig properties arrayConfig?: string // If this parameter used, must be "CONTAINS"; excludes order and vectorConfig properties vectorConfig?: object // Indicates that this is a vector index; excludes order and arrayConfig properties dimension: number // The resulting index will only include vectors of this dimension flat: {} // Indicates the vector index is a flat index FieldOverrides The schema for one object in the fieldOverrides array is as follows. Optional properties are identified with the ? character. Note that Cloud Firestore document fields can only be indexed in one mode, thus a field object cannot contain both the order and arrayConfig properties. collectionGroup: string // Labeled "Collection ID" in the Firebase console fieldPath: string ttl?: boolean // Set specified field to have TTL policy and be eligible for deletion indexes: array // Use an empty array to disable indexes on this collectionGroup + fieldPath queryScope: string // One of "COLLECTION", "COLLECTION_GROUP" order?: string // One of "ASCENDING", "DESCENDING"; excludes arrayConfig property arrayConfig?: string // If this parameter used, must be "CONTAINS"; excludes order property TTL Policy A TTL policy can be enabled or disabled using the fieldOverrides array as follows: // Optional, disable index single-field collection group indexes fieldOverrides: [ { collectionGroup: "posts", fieldPath: "ttlField", ttl: "true", // Explicitly enable TTL on this Field. // Disable indexing so empty the indexes array indexes: [] } ] To keep the default indexing in the field and enable a TTL policy: { "fieldOverrides": [ { "collectionGroup": "yourCollectionGroup", "fieldPath": "yourFieldPath", "ttl": true, "indexes": [ { "order": "ASCENDING", "queryScope": "COLLECTION_GROUP" }, { "order": "DESCENDING", "queryScope": "COLLECTION_GROUP" }, { "arrayConfig": "CONTAINS", "queryScope": "COLLECTION_GROUP" } ] } ] } For more information about time-to-live (TTL) policies review the official documentation.

```
firestore.indexes.json
```

**Pattern 7:** An index configuration file defines one object containing an indexes array and an optional fieldOverrides array. Here's an example:

```
indexes
```

**Pattern 8:** FirebaseOptions class FirebaseOptions : NSObject, NSCopying This class provides constant fields of Google APIs. defaultOptions() Returns the default options. The first time this is called it synchronously reads GoogleService-Info.plist from disk. Declaration Swift class func defaultOptions() -> FirebaseOptions? apiKey An API key used for authenticating requests from your Apple app, e.g. The key must begin with “A” and contain exactly 39 alphanumeric characters, used to identify your app to Google servers. Declaration Swift var apiKey: String? { get set } bundleID The bundle ID for the application. Defaults to Bundle.main.bundleIdentifier when not set manually or in a plist. Declaration Swift var bundleID: String { get set } clientID The OAuth2 client ID for Apple applications used to authenticate Google users, for example @“12345.apps.googleusercontent.com”, used for signing in with Google. Declaration Swift var clientID: String? { get set } gcmSenderID The Project Number from the Google Developer’s console, for example @“012345678901”, used to configure Firebase Cloud Messaging. Declaration Swift var gcmSenderID: String { get set } projectID The Project ID from the Firebase console, for example @“abc-xyz-123”. Declaration Swift var projectID: String? { get set } googleAppID The Google App ID that is used to uniquely identify an instance of an app. Declaration Swift var googleAppID: String { get set } databaseURL The database root URL, e.g. @“http://abc-xyz-123.firebaseio.com”. Declaration Swift var databaseURL: String? { get set } storageBucket The Google Cloud Storage bucket name, e.g. @“abc-xyz-123.storage.firebase.com”. Declaration Swift var storageBucket: String? { get set } appGroupID The App Group identifier to share data between the application and the application extensions. The App Group must be configured in the application and on the Apple Developer Portal. Default value nil. Declaration Swift var appGroupID: String? { get set } init(contentsOfFile:) Initializes a customized instance of FirebaseOptions from the file at the given plist file path. This will read the file synchronously from disk. For example: if let path = Bundle.main.path(forResource:"GoogleService-Info", ofType:"plist") { let options = FirebaseOptions(contentsOfFile: path) } Note that it is not possible to customize FirebaseOptions for Firebase Analytics which expects a static file named GoogleService-Info.plist - https://github.com/firebase/firebase-ios-sdk/issues/230. Returns nil if the plist file does not exist or is invalid. Declaration Swift init?(contentsOfFile plistPath: String) init(googleAppID:gcmSenderID:) Initializes a customized instance of FirebaseOptions with required fields. Use the mutable properties to modify fields for configuring specific services. Note that it is not possible to customize FirebaseOptions for Firebase Analytics which expects a static file named GoogleServices-Info.plist - https://github.com/firebase/firebase-ios-sdk/issues/230. Declaration Swift init(googleAppID: String, gcmSenderID GCMSenderID: String) -init Unavailable Unavailable. Please use init(contentsOfFile:) or init(googleAppID:gcmSenderID:) instead.

```
class FirebaseOptions : NSObject, NSCopying
```

## Reference Files

This skill includes comprehensive documentation in `references/`:

- **other.md** - Other documentation
- **reference.md** - Reference documentation

Use `view` to read specific reference files when detailed information is needed.

## Working with This Skill

### For Beginners
Start with the getting_started or tutorials reference files for foundational concepts.

### For Specific Features
Use the appropriate category reference file (api, guides, etc.) for detailed information.

### For Code Examples
The quick reference section above contains common patterns extracted from the official docs.

## Resources

### references/
Organized documentation extracted from official sources. These files contain:
- Detailed explanations
- Code examples with language annotations
- Links to original documentation
- Table of contents for quick navigation

### scripts/
Add helper scripts here for common automation tasks.

### assets/
Add templates, boilerplate, or example projects here.

## Notes

- This skill was automatically generated from official documentation
- Reference files preserve the structure and examples from source docs
- Code examples include language detection for better syntax highlighting
- Quick reference patterns are extracted from common usage examples in the docs

## Updating

To refresh this skill with updated documentation:
1. Re-run the scraper with the same configuration
2. The skill will be rebuilt with the latest information
